# Task 3: Dialogue Terminator (Natural Exit Implementation)

## Контекст (Начало нового треда)
Этот файл служит стартовым промптом для следующего треда. Мы переходим от системы удержания внимания к системе естественного завершения диалога.

**Репозиторий:** `yserjjj-2022/r-bot`
**Ветка:** `feature/volition-debug-and-fix` (или новая ветка, если вы решите сделать merge)

## Итоги предыдущего треда (Что уже сделано)
В предыдущем цикле мы успешно внедрили **Topic Transition Micrograph**:
1. Разработан и внедрен `Bifurcation Engine 2.0`.
2. Реализована защита от "Эффекта золотой рыбки" (Anti-looping) — ИИ больше не предлагает темы, схожие с текущей на уровне косинусного расстояния векторов.
3. Внедрен Feedback Loop: `hippocampus.py` теперь обновляет веса переходов в таблице `topic_transitions` на основе реакции пользователя (TEC и плотность ответа).
4. Заложен крючок `agent_intent` в БД для будущего целеполагания агентов.
5. Написана документация `docs/cognitive_architecture_v2.md`.

## Цель текущей задачи
Разрушить паттерн "вечного собеседника". Агент должен уметь детектировать ситуации, когда беседу нужно завершить (прямые прощания, выполнение задачи, эмоциональное выгорание, застревание в фатической петле), и применять одну из стратегий выхода (Graceful, Hard, Silent). Теоретическая база описана в `docs/dialogue_termination_theory.md`.

## Инструкции для локального агента (Правила работы)
1. **Протокол:** Пиши файлы целиком, без сокращений кода (никаких `# ... existing code ...`).
2. **Анализ:** Перед началом работы прочитай `docs/dialogue_termination_theory.md` и изучи текущий `pipeline.py` (особенно место после `TopicTracker` и до `Council Debate`).
3. **Согласованность:** Не ломай существующую логику TEC и Bifurcation. Terminator — это дополнительный слой контроля.

## План реализации (Шаги для агента)

### Шаг 1: Создание модуля `DialogueTerminator`
Создай новый класс/функцию (можно внутри `pipeline.py` или отдельным файлом `terminator.py`).
Модуль должен анализировать контекст (текущий текст, TEC, историю, intent) и принимать решение, используя LLM (быстрый классификатор) или эвристики.
*Ожидаемый выход:* Объект/Словарь с полями: `should_exit` (bool), `exit_type` (graceful/hard), `reason`, `suggested_message`.

### Шаг 2: Внедрение в `pipeline.py`
- Вызови этот модуль в `process_message` сразу после обновления состояния темы.
- **Для Graceful Exit:** Добавь сгенерированное сообщение в финальный промпт (`final_style_instructions`) как строгую директиву: *"Conversation has naturally concluded. Politely suggest to end it using this thought: {suggested_message}"*.
- **Для Hard Exit (Опционально на этом этапе):** Верни `CoreResponse` со специальным экшеном (`CoreAction(type="end_session")`), прерывая стандартную генерацию.

### Шаг 3: Логирование
Обязательно добавь результаты работы Терминатора в `internal_stats` (чтобы мы могли мониторить, как часто бот пытается завершить диалог).

---
**Команда для старта:**
*"Привет! Мы начинаем новый этап. Изучи файлы `docs/dialogue_termination_theory.md` и `specs/task_03_dialogue_terminator.md`. Проанализируй `pipeline.py` и предложи архитектуру для интеграции Dialogue Terminator. Жду твой план."*
